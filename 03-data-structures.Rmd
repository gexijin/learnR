# Data structures

Learning objectives:

-  Understand basic concepts of R programming, including functions and data objects.
-  Learn to seek help within R and utilize Google for programming queries.
-  Get familiar with common data objects such as scalars, vectors, lists, data frames, and matrices.

R scripts are a mix of function calls and data handling. There's a buffet of **data structures** in R, including **scalars, vectors, factors, matrices, factors, data frames**, and **lists**. These structures can store one or more individual data elements of various types, such as **numeric** (e.g. 2.5), **character** (e.g. “Go Jacks”), or **logical** (e.e. TRUE or FALSE). 

## Basic concepts
###	Expressions
In R, just type a command and watch the magic happen! For instance:
```{r}
1 + 1 
```

Here's your result, '2'. It's printed on the console right after your entry.

Now enter the string **"Go Jacks"**. (quotes are a must!)
```{r}
"Go Jacks"
```

>
```{exercise}

>
Multiply 45.6 by 78.9 and see what R computes.
```


###	Logical Values

R can yield logical values **TRUE** or **FALSE** , known as "Boolean" values in many languages. Let's try an expression that gives us a logical value:
```{r}
3 < 4 # Result in TRUE
```

And another logical value:
```{r}
2 + 2 == 5 # Spoiler: It's FALSE
```
Note that you need a double-equal sign to check whether two values are equal - a single-equal sign won't work.


###	Variables
You can store values in variables for future use, just like in other languages. Type **x = 42** to keep 42 in **x**. x is a **scalar that contains only one data element**. 
```{r}
x = 42
```

Alternatively, use this conventional and safer syntax for assignment:
```{r}
x <- 42 
```

This is the recommended way of assignment, according to the [Google R style Guide](https://google.github.io/styleguide/Rguide.xml), although ```x = 42``` generally works fine.

Once assigned, x is ready for action. Have fun with x to divide, log, square, or use it in a logical operation.
```{r}
x / 2 # Division
log(x) # Logarithm
x^2  # Squaring
sqrt(x)  # Square root
x > 1  # Logical comparison
```

You can re-assign any value to a variable at any time. Try assigning **"Go Jacks!"** to **x**.
```{r}
x <- "Go Jacks!" # Now, x is a cheerleader.
```

To peek into the variable's value, just type its name:
```{r}
x 
```

Switching to a logical value? No problem! Assign **TRUE** to **x**:
```{r}
x <- TRUE
```

You can store multiple values in a variable or object called **vector**, or **matrix** and **data frame**, which are tables with rows and columns, like an Excel spreadsheet. These will be explained later.

###	Functions
Functions are fundamental building blocks of R. Most of the times when we run R commands, we are calling and executing functions. You can call a function by its name, followed by one or more arguments in parenthesis. Let's use the **sum** function to add up a few numbers:
```{r}
sum(1, 3, 5)
```

Save a function's result to a variable:
```{r}
y <- sum(1, 3, 5)
y
```

Some arguments have "names". For example, to repeat a value 3 times, you would call the **rep** function and provide it to **times** argument:
```{r}
rep("Yo ho!", times = 3) # # Three cheers from R!
```

>
```{exercise}

>
For vector x <- c(12, 56, 31, -5, 7):             
a. Calculate the mean of all elements in x and assign it to *y*.     
b. Square each element in x and assign the results to a new vector *z*.       
```


>
```{exercise}

>
Use Google to find functions for setting and getting the current working directory, respectively.
```


>
```{exercise}

>
Discover the function that lists all the files in the current working folder. 
```


Reusing code efficiently can be achieved by wrapping it in a function, clearly defining the input and the output. Tested and documented R functions are often available as R packages. You can also define your own functions, which will be discussed later. 



###	Seeking help and example Code

To find help in R, use the help command. For instance, to learn about the sum function, type:
```{r, eval=F}
? sum 
```

A helpful document will pop up in the Help Window. See the Figure \@ref(fig:ch3-1). 

(ref:ch3-1) Help formation on the 'sum' function.

```{r ch3-1, echo=FALSE, out.width='60%', fig.cap='(ref:ch3-1)', fig.align='center'}
knitr::include_graphics("images//Ch3_1.png")
```


Scroll to the bottom of the help page to find example code, as shown in Figure \@ref(fig:ch3-2).

(ref:ch3-2) Code examples using 'sum' function.

```{r ch3-2, echo=FALSE, out.width='60%', fig.cap='(ref:ch3-2)', fig.align='center'}
knitr::include_graphics("images//Ch3_2.png")
```

The quickest way to grasp an R function is by playing around with these example codes, observing the inputs and outputs. Feel free to copy, paste, and modify these examples for your analysis needs.


**example()** brings up usage examples for the given function. Try it for the 'min' function:
```{r fig.keep='none'}
example(min)
```

Here's a quick demonstration:
```{r}
min(5:1, pi)  # Return a single number
```

Example commands and plots will show up automatically by pressing 'Return' in RStudio. In R, you'll need to manually click on the plots to view them. 
```{r message=FALSE, results='hide', warning=FALSE, fig.keep='last'}
example(boxplot)  # Show example of boxplot
```

Google is a surprisingly patient teacher for R-related queries, forgiving typos, grammar errors, and different notations. Most of your questions (99 %) have been asked and answered on various forums. Many R gurus share their wisdom on web sites like** [stackoverflow.com](stackoverflow.com)**, providing answers with example codes!  You can also use Google as a reference. 

Remember, it is important to add comments to your code. Everything after the “#” will be ignored by R during execution. Since we often recycle and re-purpose our codes, these comments are our breadcrumbs through the forest of code, helping us remember our intentions. 
```{r}
max(1, 3, 5)  # Return the maximum value of a vector
```


## Data structures
###	Vectors
A vector is an object that holds a sequence of values of the same type, such as numbers, strings, logical values, or any other type, as long as they're all the same type. They can come from a column of a data frame too. Here's how you create a vector x:
```{r}
x <- c(5, 2, 22, 11, 5)
x
```
The **c** here stands for *concatenate*. Treat it with respect and avoid using it as a variable name; it’s much too valuable for that!

Vectors can not contain values with different modes (types). Try a motley crew with mixing modes and see what happens:
```{r}
c(1, TRUE, "three")  # Converts all elements to characters
```

The result? All values get converted to 'characters', the universal diplomat of data types, to coexist peacefully in the vector. To hold diverse types of values, you will need a **list**, which is explained later in this chapter. 

For a vector with a sequence of numbers, use **start:end** notation, which is often used in loops and operations on the indices of vectors, etc. Let's create a vector with values from 5 through 9:
```{r}
5:9 
```

The **seq** function offers more flexibility for creating sequences. Here is the basic seq():
```{r}
seq(from = 5, to = 9)
```

**seq** also allows you to use increments other than 1. Try it with step of 0.5:
```{r}
seq(from = 5, to = 9, by = .5)
```

Create a sequence from 5 to 9 with length 15: 
```{r}
seq(from = 5, to = 9, length = 15)
```

>
```{exercise}

>
Compute 1+2+3… +1000 using single line of R code. Hint: check the example code for sum( ) function in the R help document.
```


#### Vectors operations

First let's find out the 4th element of our vector x <- c(5, 2, 22, 11, 5), or the elements from 2 to 4.
```{r}
x[4]
x[2:4]
```

Creat a new vector y from a segment of x:
```{r}
y <- x[2:4]
```

No result is returned but you "captured" the result in a new vector y, which holds 3 numbers. You can type y and hit 'enter' to see the results. 
```{r}
y # Meet y
```

Or, combine creation and revelation in one magical line. A semicolon separates multiple commands.
```{r}
y <- x[2:4]; y  # Voila!
```

Now discover the vector length:
```{r}
length(x)
```

It's also easy to know basic statistics about the vector such as maximum, minimum, sum, mean and median, individually or together. And standard deviation too.
```{r}
max(x)
min(x)
sum(x)
mean(x)
median(x)
summary(x)
sd(x)
```

rank() function ranks the elements. It plays fair, giving ties an average rank. sort() orders elements either ascending (from the smallest to the biggest) or descending (decreasing = T will make it sort from the biggest to the smallest).
```{r}
rank(x)
sort(x)
sort(x, decreasing = T)
```

diff() iterates the differences between adjacent elements of vector x.
```{r}
diff(x)
```

rev() will reverse the position of the elements in the vector.
```{r}
rev(x)
```

Operations are performed element by element, like log, sqrt, x^2, etc. They return vectors too.
```{r}
log(x)
sqrt(x)
x^2
2*x + 1
```

Exclude the second element from x and save as y:
```{r}
y <- x[- 2]
y
```

Add an element 100 to vector x between its second and the third element:

```{r}
x <- c(5, 2, 22, 11, 5)     
x <- c(x[1:2], 100, x[3:5] )  
x  # Now it contains the added 100                        
```

The length of the new created x is:
```{r}
length(x)
```

Use the two commands below to add a new element to the end. They generate the same results.
```{r}
x <- c(5, 2, 22, 11, 5) 
c(x, 7)
append(x, 7)
```

Create an empty vector y:
```{r}
y <- c()
y
length(y)
```

Here's how to find unique elements:
```{r}
x <- c(5, 2, 22, 11, 5) 
unique(x)
```

And the frequencies of the unique elements:
```{r}
x <- c(5, 2, 22, 11, 5)
table(x)
```

To locate the max or min, find a particular value, or satisfy a condition like $x^2>100$:
```{r}
x <- c(5, 2, 22, 11, 5)
which.max(x)
which.min(x)
which(x == 11)
which(x^2 > 100)
```

You can randomly select some elements from the vector. Do you always get the same results if you run the following code more than once? The answer is "No". Each run is a surprise, like a mini lottery:
```{r}
x <- c(5, 2, 22, 11, 5)
sample(x, 3)
```

Elements in the vector can have names. Personalize elements with names and type "x" to see the difference.
```{r}
x <- c(5, 2, 22, 11, 5)
names(x) <- c("David", "Beck", "Zach", "Amy", "John")
x  # Now it's a who's who of data!
```

You can refer to the elements by their names now.
```{r}
x["Amy"] # Amy says hi!
```

The *any()* and *all()* functions produce logical values. They return if any or all of their arguments are TRUE.

```{r}
x <- c(5, 2, 22, 11, 5)
any(x < 10)
any(x < 0)
all(x > 0)
all(x < 10)
```

Who's greater than 10 in this vector party?
```{r}
x > 10  # Raise your hand if you're over 10!
```

There are multiple methods to get a subset from a vector. Here are some examples:
```{r}
x <- c(NA, 2, -4, NA, 9, -1, 5)
x
y <- x[x < 0]  # Extract the rebels (negative values)
y
```

Vectors **x** and **y** contain annoying NA values, which can be removed using **is.na()** function. 
```{r}
y <- y[!is.na(y)]   # Remove all NAs in y. Or equivalently, keep all NOT NAs in y. 
                    # The exclamation '!' means NOT.
y
```

Now the updated variable y contains only numerical values. All NAs have been removed. To assign the "cleaned" vector to a different variable z:
```{r}
z <- y[!is.na(y)]   # Assign the new vector without NAs to z.
z                 
```
Alternatively, you can use the *subset()* function to get a "clean" data without NAs. For example: 
```{r}
x <- c(NA, 2, -4, NA, 9, -1, 5)
y <- subset(x, x < 0)
y
```

Let's peek into the function **is.na()**, which checks if a vector contains NA or not. Note that the result is a vector holding logical values. Do we have missing values in the vector x? 
```{r}
is.na(x)
```

In R, **NA** represents missing or unavailable values, like a placeholder for "I don't know."  
 
Consider the case where a given value isn't available in the data set. Unlike simply omitting values, **NA** explicitly indicates unavailability. This distinction is important for accurate data analysis. Many functions that work with vectors treat these values specially. For instance, the sum of x might not be straightforward due to NAs:
```{r}
sum(x)
```

The result **NA** is considered "not available" because one of the vector's values is **NA**. R is responsible; It won't just blithely add up the numbers without warning you about the incomplete data. However, you can explicitly tell **sum** (and many other functions) to remove **NA** values before R starts the calculations.

Let's find how **sum** function handles NAs:
```{r, eval=F}
? sum
```

As you see in the documentation, **sum** has an **na.rm** parameter to handle NA values. The optional argument **na.rm** is set to **FALSE** by default, but if you set it to **TRUE**, all NAs will be removed from the vector before the calculation is performed. In other words, you can use the argument **na.rm = T** or **na.rm = TRUE** to ignore all NAs during calculations.
```{r}
sum(x, na.rm = TRUE)  #  Calculate a sum excluding NAs
```

>
```{exercise}

>
For vector var1 <- c(NA, 334, 566, 319, NA, -307). 
>
a. Create a new vector var2 by removing all NAs from var1.
b. Calculate the mean of var1, ignoring the NAs.
```

To illustrate the difference between NULL and NA, let's experiment with vec.x:
```{r}
# Build up vec.x with numbers greater than 10 in the vector 
vec.x <- c(40, 3, 11, 0, 9)
z1 <- NULL
for (i in vec.x) {
  if (i > 10) z1 <- c(z1, i)
}
z1
length(z1) # How long is z1?
```

```{r}
# Build up vec.x with numbers greater than 10 in the vector
vec.x <- c(40, 3, 11, 0, 9)
z2 <- NA
for (i in vec.x) {
  if (i > 10) z2 <- c(z2, i)
}
z2
length(z2)  # And z2?
```

The length of **z1** and **z2** reveals that the NULL is counted as nonexistent like the invisible man, while NA is a missing value, taking up space.

Vectors in R are like the ingredients in a recipe – mix them right, you'll create data-analysis delicacies. Let's peek the operation between a vector and a scalar. 
```{r}
# Vector meets a scalar
x <- c(1, 4, 8, 9, 10)
y <- 1
x + y 
```
As you can see, 1 is added to each element in x.  The operation is equivalent adding a vector of ones to x:
```{r}
y <- c(1, 1, 1, 1, 1)
x + y
```
The operation between vectors with the same length is element-wise. For example:
```{r}
# Two vectors with the same length
x <- c(1, 4, 8, 9, 10)
y <- c(1, 2, 0, 3, 15)
x + y   # Element-wise addition
x * y   # Element-wise multiplication, each pair in sync
```

If vectors have different length, R will automatically *recycle* the shorter one, until it has the same length as the longer one. For example:
```{r warning=FALSE}
x <- c(1, 4, 8, 9, 10)
y <- c(1, 2)
x + y
```

y was *recycled*. Here's what R is really doing:
```{r}
x <- c(1, 4, 8, 9, 10)
y <- c(1, 2, 1, 2, 1)
x + y
```


*ifelse()* function allows you to choose elements conditionally. Its structure is *ifelse(test, yes, no)*. The **yes** or **no** depends on whether the test is true or false. Let's see it in action:
```{r}
x <- c(2, -3, 4, -1, -5, 6)
y <- ifelse(x > 0, 'Positive', 'Negative')
y
```
In this example, the elements in y are either 'positive' or 'negative', based on whether elements in x are greater or less than 0. 

Another twist with ifelse():

```{r}
x <- c(3, 4, -6, 1, -2)
y <- ifelse (x < 0, abs(x), 2 * x + 1) 
y
```
Here in this case, if an element in x is less than 0 (if x is negative), y takes the absolute value of the element. Otherwise (if x is positive or zero), multiply the element by 2 then add 1 for y.

>
```{exercise}

>
Randomly select 10 integers from 1 to 100 using sample selection function. Create a vector y which satisfies the following conditions: if an selected integer is an even number, y is 'even', otherwise y returns 'odd'.
```

To find where elements of one vector appear in another, use the **match()** function:
```{r}
x <- c(5, 5, 22, 11, 3)
y <- c(5, 11, 8)
z <- match(y, x) # Where do y's elements show up in x?
z # Unveil the positions
```
The elements 5 and 8 in y locate at the first and fourth position of x respectively. The function ignores the duplicated 5 which locates at the second position of x. The last element 8 in y is not found in x, which returns an "NA". 

#### An example of vector usage
Image a fishing Journey where Tom, Jerry, and Mickey went fishing and caught 7, 3, and 9 fishes, respectively, shown in a vector:
```{r}
c(7, 3, 9)
```

The **c()** function creates a new vector by combining a set of values. Give it a name if we want to use it later:
```{r}
fishes <- c(7, 3, 9)
fishes
```

**fishes** is a vector with 3 elements. Many functions can be used to operate on this vector. Let's start with a bar plot:
```{r fig.keep='none'}
barplot(fishes)  # See figure 3.3A
```

Compute the total catch:
```{r}
sum(fishes)
```

To access the individual elements by indices:
```{r}
fishes[3]
```

>
```{exercise}

>
Did Mickey catch more fishes than Tom and Jerry combined? Find out the answer using the **fishes** vector and return a TRUE or FALSE value.
```


Jerry protested that, per minimum size fishing rules, a ¼ inch long fish he caught and released was not counted in properly. So add one more to Jerry's catch by changing the value in the 2nd element:
```{r}
fishes[2] <- fishes[2] + 1 
fishes
```

Add an 1 to the current value of the 2nd element of 3, the result of 4 is assigned back to the 2nd element itself. As a result, the 2nd element is increased by 1. This is not a math equation, but a value assignment operation. More rigorously, we should write this using **<-**.

We can also directly overwrite the values. 
```{r}
fishes[2] <- 4
fishes
```

Now they started a camp fire, and each ate 1 fish for dinner. The left fishes after dinner:
```{r}
fishes2 <- fishes - 1
fishes2
```

R subtracts 1 from each individual element. Most arithmetic operations work just as well on vectors as they do on single values. If you add a scalar (a single value) to a vector, the scalar will be added to each value in the vector, returning a new vector with the results. 

Then, something bad happened in the fishing journey: While they are sleeping in their camping site, a fox stole 3 fishes from Jerry’s bucket, and 4 fishes from Mickey’s bucket. How many fishes were left now? 
```{r}
stolen <- c(0, 3, 4)  # Fishes stolen by a fox
fishes2 - stolen # Remaining fishes
```

If you add or subtract two vectors of the same length, R will take the corresponding elements from each vector and add or subtract them. The 0 is necessary to keep the same vector length.

Proud of himself, Mickey wanted to make a 5ft x 5ft poster to show himself the best fisherman. Knowing that **a picture is worth a thousand words**, he learned R and started plotting, trying to put his name on the plots. The data elements in a vector can have names or labels for a more personalized touch: 
```{r}
names(fishes) <- c("Tom", "Jerry", "Mickey")
```

The right side is a vector, holding 3 character values. These values are assigned as the names of the 3 elements in the fishes vector.  names() is a built-in function. Visualize the vector:
```{r fig.keep='none'}
fishes
barplot(fishes)   # Bar plot with names. See figure 3.3B
```

(ref:6-1) Simple Bar plot.

```{r 6-1, echo=FALSE, out.width='80%', fig.cap='(ref:6-1)', fig.align='center'}
knitr::include_graphics("images/img0601_fish.png")
```

Assigning names for a vector also enables you to use labels to access each element. Try getting the value for Jerry:
```{r}
fishes["Jerry"]  # Jerry's catch
```

>
```{exercise}

>
Assign the value 'Ten' to **Tom** using his name rather than the index in the fishes vector.
```

Tom proposes ambitiously that the goal for the next fishing trip is to double their catches. 
```{r}
2 * fishes
```

Hopelessly optimistic, Jerry proposed that next time each should “square” their catches, so that together they might feed the entire school. 
```{r}
sum(fishes ^ 2)
```

Note that two operations are nested. You can obviously do it in two steps.

>
```{exercise}

>
Create a vector representing the prices of groceries: bread $2.5, milk $3.1, jam $5.3, beer $9.1.  And visualize it with a bat plot. 
```


####	Scatter Plots of two vectors  
The **plot** function takes two vectors, one for X values and one for Y values, and creates a scatter plot. Let's explore the relationship between numbers and their square roots.

```{r}
x <- seq(1, 20, 0.1)
y <- sqrt(x)
```


Then simply call plot with the two vectors:
```{r }
plot(x, y)
```

Great job! Notice that values from the first argument (x) forms the horizontal axis, and values from the second (y) takes the vertical stage.

>
```{exercise}

>
Bring up a vector "x" with 21 integers from -10 to 10, then create a scatter plot showing x^2 against x. 
```


### Matrices 
**A matrix** is a two-dimensional vector(rows and columns) with two additional attributes: the number of rows(nrow) and the number of columns(ncol). It can only contain one type of values, i.e. numbers, characters, or logical values. 

We can create a matrix using *rbind* or *cbind* function. *rbind* combines all rows and *cbind* combines all columns:
```{r}
m <- rbind(c(3, 4, 5), c(10, 13, 15)) # Combine vectors by row
m
n <- cbind(c(3, 4, 5), c(10, 13, 15), c(3, 2, 1)) # Combine vectors by column
n
s <- rbind(m, n)   # Combine two matrices m and n by row
s
```

To use *rbind()* combining matrices by row, the matrices must have the same number of columns. Similar to *cbind()*, the matrices must have same number of rows to combine by column.

The *matrix()* function is another way to create matrices:
```{r}
x <- matrix(seq(1:12), nrow = 4, ncol = 3)
x
```
The argument *seq()* create a sequence from 1 to 12, *nrow()* and *ncol()* define the number of rows and columns in the matrix, respectively. It's not necessary to define both *nrow()* and *ncol()*. Since if one is provided, the other one is inferred from the length of the data.
```{r}
y <- matrix(seq(1:12), nrow = 4)
y
```
Notice that the matrix is filled in column-wise by default. Add the *byrow = TRUE* to the argument to fill a matrix by row-wise:

```{r}
z <- matrix(seq(1:12), nrow = 4, byrow = TRUE)    # Fill matrix row-wise
z
```
Also, you can generate a matrix by creating an empty matrix first:
```{r}
w <- matrix(nrow = 4, ncol = 3)
w
```
Then assign values to the empty matrix. For example, assign the value 3 to the position at first row and first column, and value 100 to the position of the second row and third column:
```{r}
w[1,1] <- 3
w[2,3] <- 100
w
```
A matrix can also be created from a vector by setting its dimensions using function dim().

```{r}
x <- c(1, 5, 6, 9, 8, 10, 21, 15, 76)
x
class(x)
dim(x) <- c(3, 3)
x
class(x)
```

Using *as.matrix()* function, you can convert a non-matrix data set to a matrix. Take the data *iris* as an example. 
```{r}
subset.iris <- iris[1:10, 1:4]
class(subset.iris)
```

The data structure of *subset.iris* is a data frame. Now we turn it into a matrix.
```{r}
x <- as.matrix(subset.iris) # Data frame to matrix
class(x)
```

#### Matrix operations
Matrices support a variety of operations:
```{r}
x <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2)
x
x^2 # Square each element in x
```

Transpose of x for the convenience of view and analysis:
```{r}
y <- t(x)
y
x %*% y # Matrix Multiplication
```

Subtraction requires matching dimensions:
```{r eval=F}
x - y  # Matrix subtraction
```
 Error in x - y : non-conformable arrays

The error reminds us that the matrices for subtraction must have same dimensions.
```{r}
y <- matrix(rep(1, 6), nrow = 2)    
y
x - y  # Matrix subtraction now works!
```

Create a new matrix from calculations by doubling each element and add 5:
```{r}
z <- 2 * x + 5
z
```

You can also get a logical matrix using logical code. 
```{r}
x <- matrix(c(12, 34, 51, 27, 26, 10), ncol = 2)
x > 20  # Logical matrix
```

To extract all *TRUE* results from x:
```{r}
x[x > 20]
```

Similarly, you can define a vector with logical values, then apply it to x to get all TRUE values.
```{r}
log.vau <- c(FALSE, TRUE, TRUE, TRUE, TRUE, FALSE)
x[log.vau]  # Filter by logical vector
```
Remember matrix is a vector, and filled by column-wise. Therefore the vector with logical values applies to x by column-wise order.

Since matrices are vectors with two dimensions, all operations for vectors also apply to matrices. For example:
```{r}
x[1, ]                        # Get the first row of x
a <- as.matrix(iris[, 1:4])   # Take out the first 4 columns of iris and convert it to matrix.  
c <- a[5:10, 2:4]             # Extract a subset
c
x <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2)
c[1:2, ] <- x                 # Replace the first two rows of c with x
c
```
To know the mean and sum of these rows and columns, try *rowMeans()*, *colMeans()*, *rowSums()*, *colSums()*.
```{r}
x <- as.matrix(iris[1:10, 1:4])
rowMeans(x)
colMeans(x)
rowSums(x)
colSums(x)
```

Now use **apply()** function for more complex calculations, like computing the standard deviations by columns. The second argument "1" or "2" in *apply()* represents rows or columns that the function applies to.
```{r}
apply(x, 2, sd) # Calculate the standard deviation of each column in x 
```
Or calculate medians by rows, using 1 for rows. 
```{r}
apply(x, 1, median)  # Calculate the median of each row in x 
```

Visualize a large matrix data with a heat map:
```{r}
heatmap(x, scale = "column", margins = c(10,5))
```

>
```{exercise}

>
Given *subset.iris <- as.matrix(iris[1:10, 1:4])*, calculate the column-wise mean of *subset.iris* using the **apply** function.
```


#### Examples of matrices

**Example 1: Finding Minimal Values**
Let's define a function find.min.posi first to find the positions of the minimal value in each column of a matrix,  then apply it to *subset.iris <- as.matrix(iris[1:10, 1:4])*.
```{r}
find.min.posi <- function(x){
  y <- function(xcol){
    return(which.min(xcol))
  }
  return(apply(x, 2, y))
}
```

```{r}
subset.iris <- as.matrix(iris[1:10, 1:4])
find.min.posi(subset.iris)
```
This code identifies the minimum values in each column and returns their positions. For example, the minimal value for Sepal.Length is 4.4, which locates in the 9th row. The minimal values locate in the 9th, 3rd and 10th row for Sepal.Width, Petal.Length and Petal.Width, respectively.

>
```{exercise}

>
Given *subset.iris.2 <- as.matrix(iris[, 1:4])*, complete the *find.max* function below to find the maximal value in each column of *subset.iris.2*.
>
find.max <- function(x){       
  y <- function(xcol){       
    return(_________)       
  }         
  return(_______(x, ____, y))        
}       
>
________(subset.iris.2)               
```

To enhance the readability of matrices, use functions *colnames()* and *rownames()* to assign names to the columns and rows:
```{r}
y <- rbind(c(1, 3, 5), c(2, 4, 6))
y
colnames(y) <- c('First.Col', 'Second.Col', 'Third.Col')
row.names(y) <- c('odd.number', 'even.number')
y  # Matrix with named rows and columns
```

Another interesting application of the matrix is the manipulation of gray-scale images. You may have heard a pixel matrix which represents "picture elements". They are small little dots making up images. Each image is a matrix with thousands or even millions of pixels. Each pixel can only be one color at a time, its brightness is represented by a single numeric value. The range of the colors from black to white correspond to the scale varies from 0% to 100%. If the color value 0.2941 is assigned to a pixel which locates 3rd row and 4th column, then the dot at the 3rd row and the 4th column is pretty dark. 

Sometimes it's necessary to blur images or add mosaic to a picture for various purposes. See the example of adding a mosaic effect to a gray-scale image.

**Example 2: Adding mosaic to an image of Einstein**

First, let's read and display a gray-scale image of Einstein. 
```{r warning=FALSE}
library(pixmap)
EINSTEIN <- read.pnm("images/EINSTEIN.pgm", cellres = 1)
plot(EINSTEIN)
```

Then explore the structure of this image:

```{r}
str(EINSTEIN)
```
Here you get a new data class of S4 type. Unlike data frames, you need to use "@" instead of "$" sign to access components of S4 objects.
```{r}
class(EINSTEIN@ grey)
```

*EINSTEIN@ grey* is a matrix representing pixel brightness values. The output *..@ grey : num [1:512, 1:512]* reveals the dimension of matrix  (512*512). The value of the pixel(0.2941176) at the 3rd row and the 4th column can be accessed: 
```{r}
EINSTEIN@ grey[3,4]
```
If you change the value 0.2941176 to 0 by *EINSTEIN@ grey[3,4] <- 0*, the pixel will become pure black. If you assign a random number between 0 to 1 to the value, then the color in the pixel will be randomly assigned based on the random number. To blur an image, let's define a mosaic.plot function:

```{r}
mosaic.plot <- function(image, yrange, xrange){
  length.y <- length(yrange)
  length.x <- length(xrange)
  image2 <- image
  whitenoise <- matrix(nrow = length.y, 
                       ncol = length.x, 
                       runif(length.y * length.x))
  image2@grey[yrange, xrange] <- whitenoise
  return(image2)
}
```

In this function, the argument *image* is the original image, *yrange* and *xrange* are the ranges of rows and columns that you want to blur, which means the *xrange* and *yrange* construct the mosaic region. Copy image to image2 to assure the original image unchanged. The *whitenoise* creates a matrix filled with random numbers following a uniform distribution, whose dimensions are determined by the mosaic region. Replace the values in the original image range that you want to blur *image2@grey[yrange,xrange]* by the *whitenoise* matrix.

```{r}
EINSTEIN.mosaic <- mosaic.plot(EINSTEIN, 175:249, 118:295)
plot(EINSTEIN.mosaic)
```

Here, *yrange=175:249* and *xrange=118:295* select a sub-matrix from 175th to 249th row, and 118th to 295th column. This sub-matrix stores the color values of Einstein's eyes region. The sub-matrix is replaced by *whitenoise* matrix. Therefore the image around the eyes region is replaced by image of random dots.

The function *locator()* allows you to find the relevant rows and columns for specific regions in an image. Type **locator()** in the *Console* window, R will wait for you to click a point within an image. Click *esc* on your keyboard to exit the function, then the coordinates of that point will be in the *Console* window. If you click more points once, the function will return all coordinates of these points sorted by your clicking order. You must be careful about the y-coordinate. The row numbers in *pixmap* objects increase from the top of the image to the bottom, therefore you need to opposite the y-coordinate by subtracting them from the number of rows in the original image. For example, the y-coordinates obtained from *locator()* function are actually 337 and 263. After subtracting them from 512, you get 175 and 249, which are used as *yrange* in the mosaic function. 

>
```{exercise}

>
Using the *mosaic.plot()* function to blur the image of mona_lisa.pgm by adding mosaic to the eyes region. Your output should look like the graph below.
```
>
```{r echo = FALSE}
# Mona lisa 
library(pixmap)
mona.lisa <- read.pnm("images/mona_lisa.pgm", cellres = 1)
#str(mona.lisa)
#plot(mona.lisa)
#locator()
mona.lisa.mosaic <- mosaic.plot(mona.lisa, 60:85, 81:150)
plot(mona.lisa.mosaic)
```

>
```{exercise}

>
Modify the following function so that the eyes region of Mona Lisa image is covered by a pure color but mosaic. Experiment with different color intensities by setting the degree = 0, 0.5 and 1 respectively, plot the images.     
mosaic.plot.2 <- function(picture, yrange, xrange, degree){          
  length.y <- _______(yrange)          
  length.x <- length(______)          
  pic2 <- picture          
  pic2@____[_______,_______] <- degree          
  return(pic2)          
}          
```


### Data Frames
Data frames are fundamental in R for handling two-dimensional datasets. Unlike matrices, data frames can have different modes (types) for each column, which makes them a universal tool for data analysis. In fact, a data frame is a special case of a two-dimensional list. The data set *iris* that we analyzed before is a classic example of a data frame. 
```{r}
class(iris)
head(iris)
```

#### properties of a data frame
There are some **properties of a data frame**. 

1. **Diverse Column Modes**: Data frames can contain columns of various types: numeric, factor, or character. For instance, Sepal.Length in data frame iris is numeric, while Species is a factor.
```{r}
class(iris$Sepal.Length)
class(iris$Species)
```
2. **Non-Empty Column Names**: Typically, each column name represents a different variable. There are 5 column names or variables in the *iris* data set, they are Sepal.Length, Sepal.Width,  Petal.Length, Petal.Width, and Species,  respectively.
```{r}
colnames(iris)
```
3. **Uniform Column Lengths**: All columns in a data frame should have the same number of data points. This ensures each variable has the same number of observations. There are 150 observations for each variable in the *iris* data.

4. **Unique Row Names**: The row names are unique. If they are not pre-named, the indices "1", "2", "3", $\cdots$, "n" will be assigned to each row, where "n" is the length of rows or the number of observations. The row names of *iris* are shown below:
```{r}
rownames(iris)
```

#### Basic operations
A data frame can be created by combining vectors with the function *data.frame()* . For example:
```{r results='hide'}
x <- c("A", "B", "C", "D")
y <- c(41, 32, 13, 89)
z <- c("TRUE", "FALSE", "FALSE", "TRUE")
df1 <- data.frame(x, y, z)
df1
```

```{r echo=FALSE, fig.width = 4, fig.align='center'}
knitr::include_graphics("images/img0300_CharacterToFactor.png")
```

The *\<fctr\>*s underneath x and z in the output mean that character vectors x and z are automatically converted to factors. You can check the change by the *class()* function:
```{r}
class(x)
class(df1$x)
```
To prevent automatic conversion to factors, use an argument *stringsAsFactors = FALSE* in the *data.frame()* function. 
```{r}
df2 <- data.frame(x, y, z, stringsAsFactors = FALSE)
df2
class(df2$x)
```

>
```{exercise}

>
Determine the class of the R built-in data set *mtcars* using appropriate functions.
```

**Data frame** support various functions for data analysis.
Read in data frame x firstly:
```{r}
x <- iris
```

Using summary() to get descriptive statistics of each column.
```{r}
summary(x)
```

head() and tail() functions show the fist and last few rows.
```{r}
head(x)
tail(x)
```

Dimensions of the data frame (rows and columns):
```{r}
dim(x)
```

You can just get number of rows or number of columns separately:
```{r}
nrow(x)
ncol(x)
```

str() is a very useful function, which shows data types for all columns.
```{r}
str(x)
```

Like in matrix, individual elements can be accessed in a data frame. Let's select the element in the second row and third column:
```{r}
x[2, 3]
```

Also you can subtract a subset data frame from x. For example, to extract the columns 2 to 4 and rows 1 to 10:
```{r}
x[1:10, 2:4]
```

Now view the first column:
```{r}
x[, 1]
```

Column selection can also be done using the data frame name x followed with the column name.
```{r}
x$Sepal.Length
```

The argument *drop=FALSE* will keep a one-column vector as a data frame. For example:
```{r}
class(x[, 1])
class(x[, 1, drop = FALSE])
```

Use mean() function if you need to know the average Sepal Length. By the way, expressions can be nested.
```{r}
mean(x$Sepal.Length)
```

It's very common to select a subset of data by certain columns or by certain conditions, using logical operations. The "==", ">", and "<" are logical operations and the "=" is an equality sign for assigning value. 
Let's get a subset which contains only the species of setosa:
```{r}
y <- subset(x, Species == "setosa")
head(y)
```

A subset that the length of sepal are greater than 7:
```{r}
subset(x, Sepal.Length > 7)
```

If more than one condition are applied to the data, use **&** to connect the conditions. For example, to extract a subset which contains only the species of virginica, the sepals more than 7cm long, and the length of petal removed:
```{r}
x.3conds <- x[x$Sepal.Length > 7 & x$Species == "virginica", - 3]       # -3 means removing the 3rd column from x.
```

>
```{exercise}

>
From data set *mtcars*, select a subset where *cyl* is 6 and *mpg* is greater than 21.2, excluding the variable *carb*.
```

#### Advanced techniques and analysis
Data frames can be modified by adding new columns or rows. Let's add a new column named "id" to the data frame x, which goes from 1 to 150. Function *head()* is used to view the first 6 rows of the new data set.
```{r}
x.id <- cbind(id = c(1:150), x)
head(x.id)
```

Add another column of random numbers y to x.id.
```{r}
y <- rnorm(150)
x2 <- cbind(y, x.id)
head(x2)
```

Similar to cbind(), rbind() is for adding another exist row or rows with same length of columns. Now use tail() to examine the result.
```{r warning=FALSE}
newRow <- c(1, 1, 1, 1, "setosa", 151)
x3 <- rbind(x, newRow)
tail(x3)
```

You can sort the data frames by a specific columns, either in ascending or descending order. For example, to sort the first column in ascending, and the second column in descending:
```{r}
y <- x[order(x[, 1]), ]
head(y)
y <- x[rev(order(x[, 2])), ]
head(y)
```

It's common to visualize the distribution of a variable grouped by another. For instance, use boxplot to observe sepal length distribution across species:
```{r}
boxplot(Sepal.Length ~ Species, x)
```

You can perform statistical analyses by category, like mean of the variables by species:
```{r}
aggregate(. ~ Species, x, mean)
```

>
```{exercise}

>
Use *aggregate()* to calculate medians for variables *mpg*, *disp*, *hp*, and *wt* in data set *mtcars* across *cyl*.
```

Statistical analysis such as ANOVA and regression analysis are also possible with data frames. Let's perform analysis of variance, named ANOVA, to test whether sepal length has significant difference among species.
```{r}
m <- aov(Sepal.Length ~ Species, iris)
summary(m)
```
The p-value is close to 0, therefore the null hypothesis is rejected and you can conclude that the length of sepal among three species are not same.

The *sapply()* function applies functions across columns, so that you can do the ANOVA test for all of the 4 numeric variables across the species at once. 

```{r}
aov.fun <- function(temx){
  m1 <- aov(temx ~ iris$Species)
  summary(m1)
}
nvar <- iris[- 5]  # Remove the variable Species
da <- sapply(nvar, aov.fun)   # Apply aov.fun() function to each variable in the data set nvar 
da
```

Regression analysis uses linear model(lm) to analyze the relationship between these columns. Here sepal length is used as a function of sepal width and petal length, plus error.
```{r}
m <- lm(Sepal.Length ~ Sepal.Width + Petal.Length, x)
summary(m)
```

>
```{exercise}

>
Test if *mpg*, *disp*, *hp*, *wt* and *qsec* significantly differ across *cyl* in *mtcars*. Fill the blanks and interpret your conclusion based on the p-values.            
>              
aov.fun.car <- function(temx){                         
  m2 <- ________(________ ~ _________$______)                                   
  summary(________)                  
}                  
sub.car <- mtcars[, ___________]                                 
aov.car <- ___________(_________, __________)                              
____________                  
```

You can merge two data frames by the function *merge()*.
```{r}
dfmg1 <- data.frame(V1 = c("A", "B", "C", "D"), V2 = c(90, 80, 70, 60), stringsAsFactors = FALSE)
dfmg1
dfmg2 <- data.frame(V1 = c("A", "C"), W2 = c(95, 85), stringsAsFactors = FALSE)
dfmg2
merge(dfmg1, dfmg2)

```

The two data frames dfmg1 and dfmg2 here have the same variable V1. After merging, the rows with common elements "A" and "C" in both V1s are selected.
To merge two data frames with columns contain similar information but different names, use *by.x* and *by.y* arguments to specify the variable names in the first and second data frame, respectively. 

```{r}
dfmg3 <- data.frame(W1 = c("A", "F", "C"), W2 = c(95, 85, 65), stringsAsFactors = FALSE)
dfmg3
merge(dfmg1, dfmg3, by.x = "V1", by.y = "W1")
```

Now use data.frame() function to define a new data frame with 100 rows and two columns, *ids* and *rand*.
```{r}
y <- data.frame(id = 1:100, rand = rnorm(100))
head(y)
tail(y)
```

You can merge two data frames with different rows. Note the new data frame z has only 100 rows after merging x and y by the common column name **id**. 
```{r}
x <- iris
x$id = c(1:150)
z <- merge(x, y, by = "id")
head(z)
tail(z)
summary(z)
```

You can also merge data frames by row names too, by adding row names as a new column in each data frame. 
```{r}
# Create sample data frames
df1 <- data.frame(A = c(1, 2, 3), B = c(4, 5, 6))
rownames(df1) <- c("row1", "row2", "row3")

df2 <- data.frame(C = c(7, 8, 9), D = c(10, 11, 12))
rownames(df2) <- c("row1", "row2", "row3")

# Add row names as a new column in each data frame
df1$RowName <- rownames(df1)
df2$RowName <- rownames(df2)

# Merge the data frames by the common column "RowName"
merged_df <- merge(df1, df2, by = "RowName")
```


### Strings and string vectors
String manipulation is a common task in data analysis, especially when dealing with textual data. Let's dive deeper into single-string operations, handling string vectors, and an advanced example involving DNA sequences.

#### Working with a Single String

Define a **string** x:
```{r}
x <- "R is cool"
```

Count the number of characters:
```{r}
nchar(x)
```

Concatenate strings(with a space by default):
```{r}
paste(x, "!!")
```

Extract sub-string (from position of 6 and 9):
```{r}
substr(x, 6, 9)
```

Split string into a list separated by space:
```{r}
strsplit(x, " ")
```

Replace "R" with "Tim":
```{r}
gsub("R", "Tim", x)
```

Remove everything after a space:
```{r}
gsub(" .*", "", x)
```

Check for the pattern "is":
```{r}
grepl("is", x)
```

Convert to lowercase or uppercase:
```{r}
tolower(x)
toupper(x)
```

#### Handling String Vectors
A **string vector** can hold many strings. This can be a column of names or IDs in a table.
First let's define a string vector: 
```{r}
x <- c("ab", "cde", "d", "ab") 
```

You can use all commands about vector for string vector, such as accessing 2nd element in vector:
```{r}
x[2]
```

Determine the number of strings in the vector:
```{r}
length(x)
```

Find unique elements:
```{r}
unique(x)
```

Is there any duplicated element in the vector?
```{r}
duplicated(x)
```
The last element is duplicated.

Count characters in each element:
```{r}
nchar(x)
```

You can also unite two string vectors x and y if another vector y is defined first:
```{r}
y <- c("ab", "e")
union(x, y)
```

Is there intercept among these two sets of strings?
```{r}
intersect(x, y)
```

Add something like "Q" to each element:
```{r}
paste(x, "Q")
```

To avoid the space between these elements and "Q", try paste0():
```{r}
paste0(x, "Q")
```

Collapse multiple strings into one joined by space:
```{r}
paste(x, collapse = " ")
```

#### Advanced Example: Manipulating DNA Sequences
Let's experiment with a list practically. Consider a piece of DNA sequence:
```{r}
DNA <- "taaCCATTGtaaGAACATGGTTGTCcaaaCAAGATGCTAGT"
```

Note that the assignment operator “<-” is used here. “=” can also function correctly in many instances but has the potential to be ambiguous. 

First, convert everything to upper case. 
```{r}
DNA <- toupper(DNA)
```

Next, cut this DNA into smaller pieces by the pattern “ATG”. This type of thing happens in nature, as some enzymes cut DNA according to a certain pattern. 
```{r}
segs <- strsplit(DNA, "ATG")  # Split by "ATG"
```

The result is contained in 'segs' as a **list**, which will be discussed later in this chapter. The unlist( ) function converts list into a string vector. 
```{r}
segs <- unlist(segs)   
segs  # A vector of strings
segs[1]  # First segment
```

>
```{exercise}

>
In the **iris** dataset, define a new column *FullName* containing the full species name by adding “Iris” in front of each species name. For example, “setosa” becomes “Iris setosa”.
```

Note: some of the materials above have been inspired by  [http://tryr.codeschool.com/](http://tryr.codeschool.com/), which contains more in-depth information on string manipulation in R.


### Lists
Lists are adaptable structures in R that can hold objects of different types, overcoming the limitations of vectors.

#### List creating, modifying, and accessing
Let's start by creating a simple list:
```{r}
y <- list(5, "John Doe", c(100, 7), mean)  # A list with 4 components
y
```

You can associate each components with a *tag* for easy reference.
```{r}
y <- list(height = 5, name = "John Doe", BP = c(100, 77), fun = mean)  
y
```

Here is another way to create a list:
```{r}
x1 <- matrix(c(4, 2, 5, 6, 10, 9), ncol = 3) # Matrix
x2 <- 8 : 1 # Vector
x3 <- c(2.4, 5.1, 9.0, 4.4)  # Numeric vector
x4 <- c('u', 'v', 'w')  # Character vector
z <- list(x1, x2, x3, x4)  # Combine into a list
z
```

Or build a list by assigning values to an empty list:
```{r}
v <- list()         # Create an empty list
v[[1]] <- matrix(c(4, 2, 5, 6, 10, 9), ncol = 3)  # Assign a matrix to v[[1]]
v[[2]] <- 8 : 1    # Assign a vector to v[[2]]
v[[3]] <- x3       # Assign x3 to v[[3]] where x3 is defined as above
v[[4]] <- x4       # Assign x4 to v[[4]] where x4 is defined as above
v
```
List 'z' and 'v' are identical despite being created differently, because they are assigned with the same components.

There are several different ways to access the elements in a list. For example, to access the third component in y:
```{r}
y <- list(height = 5, name = "John Doe", BP = c(100, 77), fun = mean)
y[[3]]        # Specify the number in a double square bracket
y$BP          # Use $ sign and tag
y[["BP"]]     # Use the tag in a double square bracket
```
Note that **double square bracket** '[[]]' is used here, which is different from using single square brake '[]' in a vector. For a list, single square brackets return a sublist, while double square brackets return the actual element. For example, y[3] returns a list, y[[3]] returns a numerical vector. Use functions *class()* and *is.list* to check the type of the returned object:
```{r}
y[3]
class(y[3])               # Get the class of y[3]
is.list(y[3])             # Check if y[3] is a list or not
y[[3]]
class(y[[3]])             # Get the class of y[[3]] 
is.list(y[[3]])           # Check if y[[3]] is a list or not
```

Lists can store functions as elements. For example, the forth component of y is *fun = mean*. There are no quotation marks around *mean*. The *class(y[[4]])* returns a function. 
```{r}
class(y[[4]])
```

This implies that y[[4]] is the same as the *mean()* function. To apply it to a numeric vector:

```{r}
y[[4]](c(1, 2, 3, 4, 5))          # Get the mean of 1, 2, 3, 4, 5
```

>
```{exercise}    

>
Given list1 <- list(Name = "Tom", Hobby = "Fishing", Num.fish = c(16, 27, 5))
>
Access the second component in list1 using three ways we introduced above. What are the types of list1["Hobby"] and list1[["Hobby"]], respectively?      
```

#### List operations

-  Modify an element:
```{r}
y <- list(height = 5, name = "John Doe", BP = c(100, 77), fun = mean)
y[[2]] <- "Mike"    # Change the 2nd component from "John Doe" to "Mike"
y[[4]] <- NULL      # Delete the 4th component by setting it to NULL
y
```

The output shows that the name has been changed to Mike and the mean function is deleted. So far, the length of y is 3:
```{r}
length(y)
```

Add the forth components to y: 

```{r}
y$class <- c("math", "art")  # Add a class component
y
```

-  Create Lists with Tag-Value Associations: 

For example, associate the names and values into a list by creating an empty list and then fill it via assignment statements:
```{r}
sales <- c(100, 105, 98, 112)
seasons <- c("Spring", "Summer", "Fall", "Winter")
sale.tag <- list()          # Create an empty list
sale.tag[seasons] <- sales  # Associate sales data with seasons
sale.tag
```

Or, we can assign each component corresponding value or vector individually.
```{r}
sale.tag <- list()          # Start with an empty list
# Assign values to specific seasons
sale.tag[["Spring"]] <- 100
sale.tag[["Summer"]] <- 105
sale.tag[["Fall"]] <- 98
sale.tag[["Winter"]] <- 112
sale.tag
```

>
```{exercise}  

>
For data set sale.tag, choose all correct answers from the following options A - F to answer the questions a, b, c:         
  A: sale.tag[[1]]                  
  B: sale.tag[[Spring]]                      
  C: sale.tag[["Spring"]]                      
  D: sale.tag["Spring"]                   
  E: sale.tag[1]                    
  F: sale.tag[Spring] 
>
a. Which options return a vector.  Answer:___________                 
b. Which options return a list.    Answer:___________                
c. Which options return an error.  Answer:___________                
```

-  List calculation:

Basic statistical functions work on vectors won't do the same job on lists: 

> mean(sale.tag)                
[1] NA                
Warning message:                
In mean.default(sale.tag) :                
  argument is not numeric or logical: returning NA               

Before calculation, you need to use function *unlist()* to flatten the list into a vector:
```{r}
mean(unlist(sale.tag))
```

Similar to *apply()* function for vectors, *lapply()* (for list apply) works on each component of a list:
```{r}
x <- list(c(10, 20, 30), c(4, 5, 6, 7, 8))
mean.x <- lapply(x, mean)
mean.x
```
The *mean.x* returns a list consisting of 20 and 6, which are means of components of x respectively. 

Let's redo the previous example by using function *sapply()* for a simpler output as vector or matrix. 
```{r}
mean.x.2 <- sapply(x, mean)
mean.x.2
```

Check the output type by *class()* or *is.vector()* function:
```{r}
class(mean.x)               
class(mean.x.2)             
is.vector(mean.x.2)
```

Here is another example for *sapply()* function to filter out NULL elements. First apply *is.null* function to every element in the list, which will produce a vector with logical values. Then delete the element by setting NULL to it if the logical value comes as *TRUE* for the element.
```{r}
list.null <- list('art', NULL, c(2, 4, 6, 8))
list.null
list.null[sapply(list.null, is.null)] <- NULL
list.null
```
For large datasets, **sapply()** is efficient to remove NULL elements.
But for a smaller size dataset, it's much easier to directly setting NULL to the NULL element in a known position. For example, we set a NULL to the second element of list.null:
```{r}
list.null <- list('art', NULL, c(2, 4, 6, 8))
list.null[[2]] <- NULL  # Remove NULL elements
list.null
```

#### Example using list

Lists in R are incredibly versatile, allowing you to efficiently manage and manipulate complex sets of data.

Suppose we have a list of customers who visited a store in the last 10 days. Some customers visited it more than once. The customer names are recorded by the order of the day they came:

```{r}
customer <- list("Alex", "Brandon", "Alex", "Daniel", "Grace", "Mary", 
                 "Mary", "Alex", "Tom", "Grace")
```

To find out the days and the total number of days that each customer visited the store, here is a function which returns all locations of the same elements in a list. 

```{r}
loc.names <- function(f){
  y <- unlist(f)                      # Flatten a list x into a vector y
  x <- list()                         # Create an empty list
  for (i in 1:length(y)){        
    c.name <- y[i]                    # Assign the ith element to c.name. 
    x[[c.name]] <- c(x[[c.name]], i)  # Assign values to x[[c.name]]. c.name is the name of x
  }
  return(x)
}
```

When you apply the function, the *f* will be replaced by your own list, like **customer**.        
x <- list () creates an empty list.      
In the *for* loop, i starts from 1 to the length of vector y. In the customer example, the length of y is 10.  
*c.name <- y[i]* assigns the i-th element in y to a new variable *c.name*. For example, if i = 1, y[1] is the "Alex", then *c.name = "Alex"*. 

*x[[c.name]] <- c(x[[c.name]], i)* : 

For i = 1, you have *c.name <- "Alex"*, then *x[[c.name]] = x[["Alex"]] = NULL* since x starting from an empty list. Therefore c(x[["Alex"]], i) = c(NULL, i) = i = 1. The value 1 will be assigned to x[["Alex"]] by the code: *x[["Alex"]] <- c(x[["Alex"]], i) = 1*. Now x is not an empty list, it is a list with 1 component:

```{r}
x <- list()
x[["Alex"]] <- 1
x
```
For i = 2, y[2] <- "Brandon", then similar to the case of i = 1, you have *x[["Brandon"]] <- 1*:
```{r}
x[["Brandon"]] <- 1
x
```

For i = 3, *y[3] <- "Alex"*. You have met "Alex" once, which returned *x[["Alex"]] <- 1*. Now you meet "Alex" again, which means you are going to update *x[["Alex"]]* by *x[["Alex"]] <- c(x[["Alex"]], i) = c(1, i) = c(1, 3)*. The updated x is:

```{r}
x[["Alex"]] <- c(1, 3)
x
```

The process will stop till i = length (y) = 10. The *loc.names()* function will return all locations of all names which are already stored in x. 

Now let's apply the function to the customer list.
```{r}
customer <- list("Alex", "Brandon", "Alex", "Daniel", "Grace", "Mary", 
                 "Mary", "Alex", "Tom", "Grace")
v1 <- loc.names(customer)
v1
```

The output reveals the days each customer visited the store: Alex visited store at the first, third and eighth days, Brandon came on the second day, etc.


Next, use *sapply()* function to calculate the total number of visits per customer.

```{r}
v2 <- sapply(v1,length)     # calculate the repeat times of each element in v1
v2
```

Then, sort the visit frequency in decreasing order:
```{r}
sort(v2, decreasing = T)
```

>
```{exercise}       

>
Fill in the blanks in the function *my.fun()* and apply it to a list of genders. The function should return all element locations and sort the frequencies in increasing order. 
The geneder set includes: 
      F F M M M M I I F I F M I F M I I M I I F   
Where F, M, and I represent Female, Male, and Infant, respectively.

>
my.fun <- function(f){
  y <- unlist(f)                         
  x <- ___________                                     
  for (i in 1:____){                      
    g1 <- y[i]                        
    x[[______]] <- c(x[[____]],i)                 
  }
  freq <- _________(x, length)                       
  z <- sort(________, decreasing = ____)                      
  lst <- list(x, z)                      
  ___________(lst)                      
}                          
gender <- list( "F", ________________________________, "F")                    
__________(gender)                                                                 
```


Many R functions, such as *t.test()*, return results as **list**s, which contain a series of components, such as p-values, vectors of residuals or coefficients, and even matrices.  A list combines everything into one big object that is easy to break down and understand.

To compare two sets of random numbers:
```{r}
r1 <- rnorm(100)  # Create 100 random numbers following Normal Distribution
r2 <- rnorm(100)
t.result <- t.test(r1, r2) # Run the t test. Test if the mean of r1 and r2 are same
is.list(t.result) # Check if the t.result is a list
t.result  # A list holds all components of t-test
names(t.result) # Return all tags of the t test result
t.result$p.value  # Retrieve  p-value for the test
t.result$estimate  # Return mean of r1 and r2
```
The t-test result is efficiently stored in a list, providing structured access to various test outcomes like p-values and estimates. Run the '?t.test' to access the help page for more information about types of returned values and their names.

Finally, let’s run a simulation with lists, using a loop. We will generate two sets of 100 random numbers from the standard normal distribution with zero mean and unit standard deviation, then perform t-test and get the p-value. By repeating this process 500 times, observe the distribution of p-values and count significant results with p < 0.05. 

```{r }
pvalues <- rep(1, 500)  # Define a vector containing 500 numbers, all equal to 1
for (i in 1:500) {  # Loop: The values of i takes values from 1,2,3, …, 500
  result = t.test(rnorm(100), rnorm(100))    
  pvalues[i] = result$p.value  # p-values are stored in the i-th element in the vector
}  
hist(pvalues)  # Histogram of p-values
summary(pvalues)   
sum(pvalues < 0.05)  # Total number of p-value's which are less than 0.05
```
This simulation demonstrates how lists can be effectively used to store and analyze results from repetitive statistical tests.

